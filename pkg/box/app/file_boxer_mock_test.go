// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package app

import (
	"github.com/diego1q2w/drop-box-it/pkg/box/domain"
	"sync"
)

var (
	lockfileBoxerMockWriteFile sync.RWMutex
)

// Ensure, that fileBoxerMock does implement fileBoxer.
// If this is not the case, regenerate this file with moq.
var _ fileBoxer = &fileBoxerMock{}

// fileBoxerMock is a mock implementation of fileBoxer.
//
//     func TestSomethingThatUsesfileBoxer(t *testing.T) {
//
//         // make and configure a mocked fileBoxer
//         mockedfileBoxer := &fileBoxerMock{
//             WriteFileFunc: func(file domain.File) error {
// 	               panic("mock out the WriteFile method")
//             },
//         }
//
//         // use mockedfileBoxer in code that requires fileBoxer
//         // and then make assertions.
//
//     }
type fileBoxerMock struct {
	// WriteFileFunc mocks the WriteFile method.
	WriteFileFunc func(file domain.File) error

	// calls tracks calls to the methods.
	calls struct {
		// WriteFile holds details about calls to the WriteFile method.
		WriteFile []struct {
			// File is the file argument value.
			File domain.File
		}
	}
}

// WriteFile calls WriteFileFunc.
func (mock *fileBoxerMock) WriteFile(file domain.File) error {
	if mock.WriteFileFunc == nil {
		panic("fileBoxerMock.WriteFileFunc: method is nil but fileBoxer.WriteFile was just called")
	}
	callInfo := struct {
		File domain.File
	}{
		File: file,
	}
	lockfileBoxerMockWriteFile.Lock()
	mock.calls.WriteFile = append(mock.calls.WriteFile, callInfo)
	lockfileBoxerMockWriteFile.Unlock()
	return mock.WriteFileFunc(file)
}

// WriteFileCalls gets all the calls that were made to WriteFile.
// Check the length with:
//     len(mockedfileBoxer.WriteFileCalls())
func (mock *fileBoxerMock) WriteFileCalls() []struct {
	File domain.File
} {
	var calls []struct {
		File domain.File
	}
	lockfileBoxerMockWriteFile.RLock()
	calls = mock.calls.WriteFile
	lockfileBoxerMockWriteFile.RUnlock()
	return calls
}
